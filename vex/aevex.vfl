#include <math.h>

// ==========================
// TODO
// ==========================
// MAKE GALLERY PRESETS FOR MORE OF THESE?
// Line-Line Dist
// ptlined with extras
// circ from 2/3 pts etc?

// ==============================
// Vector manipulation
// ==============================

vector topolar(vector v)
{
    float r = length(v);
    float th = acos(v.z/r);
    float phi = atan2(v.y, v.x);
    vector a = set(r,th,phi);
    return a;
}

vector frompolar(vector v)
{
    float x=v.x*sin(v.y)*cos(v.z);
    float y=v.x*sin(v.y)*sin(v.z);
    float z=v.x*cos(v.y);
    vector a = set(x,y,z);
    return a;
}

vector toPolar(vector v){
    return topolar(v); 
}

vector toCartesian(vector v){
    return frompolar(v); 
}


// forward and reverse stereographic projection from 3D-4D
vector4 inverseStereo4(vector p; float mul) {
    float n = dot(p,p)+1;
    return set(p.x*(mul/n),p.y*(mul/n),p.z*(mul/n),(n-2)/n);
}

vector stereo4(vector4 p; float mul) {
    return set(p.x/(1-p.w),p.y/(1-p.w),p.z/(1-p.w));
    //return set(p.x/(1+p.w),p.y/(1+p.w),p.z/(1+p.w)); wrong but fun  
}


// from hemesh
float distToLine3D(vector p ; vector la; vector lb){
    vector ab = lb - la;
    vector ap = p - la;
    float e = dot(ap, ab);
    float f = dot(ab, ab);
    float d2 = dot(ap, ap) - e*e/f;
    return sqrt(d2);
}

// ==============================
// Useful maths functions
// ==============================

float bias(float t, bias){
    return (t / ((((1.0/bias) - 2.0)*(1.0 - t))+1.0));
}

float gain(float t, gain){
    if(t < 0.5) {
        return bias(t * 2.0,gain)/2.0;
    }   
    else { 
        return bias(t * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;
    }
}

float smoothstep(float x){                
    return x * x * (3 - 2 * x);
}

float smootherstep(float x){                
    return x*x*x*(x*(x*6 - 15) + 10);
}

float smoothstep(float e0, e1, t){                
    float x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x * x * (3 - 2 * x);
}

//double smoothstep
float doublesmoothstep(float e0, e1, e2, e3, t){                
    float x = smoothstep(e0, e1, t);
    float y = 1- smoothstep(e2, e3, t);
    return min(x, y);
}

// ends at 0 and 1
float doublesmoothstep(float e1, e2, t){                
    float x = smoothstep(0, e1, t);
    float y = 1- smoothstep(e2, 1, t);
    return min(x, y);
}

float smootherstep(float e0, e1, t){                
    float x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x*x*x*(x*(x*6 - 15) + 10);
}

vector smoothstep(float e0, e1; vector t){                
    vector x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x * x * (3 - 2 * x);
}

vector smootherstep(float e0, e1; vector t){                
    vector x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x*x*x*(x*(x*6 - 15) + 10);
}

// clamps to new range and then fits back to initial range
float fitclamp(float t, clampStart, clampEnd, fitStart, fitEnd){
    return fit(clamp(t, clampStart, clampEnd), clampStart, clampEnd, fitStart,fitEnd);
}

// clamps to new range and then fits back to 0-1
float fitclamp01(float t, clampStart, clampEnd){
    return fit(clamp(t, clampStart, clampEnd), clampStart, clampEnd, 0,1);
}

// maps a 0->1 edge of the form _/'' to a symmetric triangular pulse (0->h->0) over the edge width _/\_ 
float ramptotri(float t, h){
    float a = 1-2*abs(0.5 - t);
    return a*h;
}

float ramptotri(float t){
    return 1-2*abs(0.5 - t);
}

float heading(vector2 v){
    return atan2(v.y, v.x);
}

vector heading(vector v){
    return set(atan2(v.y, v.x), atan2(v.z, v.x), atan2(v.z, v.y));
}

// rint with float step
float rfloat(float step, value){
    return step * rint(value/step);
}

float floorfloat(float step, value){
    return step * floor(value/step);
}


// ==============================
// Geometry functions (use ptnum or primnum etc)
// ==============================

// This is perhaps quite slow?
float curveuv(int ptnum, primnum){
    int v = pointvertex(geoself(), ptnum);
    int ind = vertexprimindex(geoself(), v);
    int npts = len(primpoints(0, primnum));
    return float(ind) / (npts-1);
}

int primpointsfrompt(int ptnum){
    int v = pointvertex(geoself(), ptnum);
    int ind = vertexprimindex(geoself(), v);
    int npts[] = primpoints(0, primnum);
}

// ==============================
// Arrays
// ==============================

// shuffle array (Basic Fisher-Yates) NOT WORKING ###############################
void shuffle(int array[]){
    int n = len(array);
    if (n > 1) {
        for (int i = 0; i < (n - 1); i++) {
          int j = (i + n*int(rand(34334+i*123)))%n;
          int t = array[j];
          array[j] = array[i];
          array[i] = t;
      }
  }
}
