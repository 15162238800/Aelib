#include <math.h>

// ==============================
// Vector manipulation
// ==============================

vector toPolar(vector v)
{
    float r = length(v);
    float th = acos(v.z/r);
    float phi = atan2(v.y, v.x);
    vector a = set(r,th,phi);
    return a;
}

vector toCartesian(vector v)
{
    float x=v.x*sin(v.y)*cos(v.z);
    float y=v.x*sin(v.y)*sin(v.z);
    float z=v.x*cos(v.y);
    vector a = set(x,y,z);
    return a;
}

// ==============================
// Useful maths functions
// ==============================
// ==============================

float bias(t, bias){
    return (t / ((((1.0/bias) - 2.0)*(1.0 - t))+1.0));
}

float gain(t, gain){
    if(t < 0.5) {
        return bias(t * 2.0,gain)/2.0;
    }   
    else { 
        return bias(t * 2.0 - 1.0,1.0 - gain)/2.0 + 0.5;
    }
}



float smoothstep(float x){                
    return x * x * (3 - 2 * x);
}

float smootherstep(float x){                
    return x*x*x*(x*(x*6 - 15) + 10);
}

float smoothstep(float e0, e1, t){                
    float x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x * x * (3 - 2 * x);
}

float smootherstep(float e0, e1, t){                
    float x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x*x*x*(x*(x*6 - 15) + 10);
}

vector smoothstep(float e0, e1; vector t){                
    vector x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x * x * (3 - 2 * x);
}

vector smootherstep(float e0, e1; vector t){                
    vector x = clamp((t - e0) / (e1 - e0), 0.0, 1.0);
    return x*x*x*(x*(x*6 - 15) + 10);
}

// clamps to new range and then fits back to initial range
float fitclamp(float t, clampStart, clampEnd, fitStart, fitEnd){
    return fit(clamp(t, clampStart, clampEnd), clampStart, clampEnd, fitStart,fitEnd);
}

// clamps to new range and then fits back to 0-1
float fitclamp01(float t, clampStart, clampEnd){
    return fit(clamp(t, clampStart, clampEnd), clampStart, clampEnd, 0,1);
}

// OLD
// float fitclamp(float clampStart, clampEnd, fitStart, fitEnd, t){
//     return fit(clamp(t, clampStart, clampEnd), clampStart, clampEnd, fitStart,fitEnd);
// }

// // clamps to new range and then fits back to 0-1
// float fitclamp01(float clampStart, clampEnd, t){
//     return fit(clamp(t, clampStart, clampEnd), clampStart, clampEnd, 0,1);
// }

// maps a 0->1 edge of the form _/'' to a symmetric triangular pulse (0->h->0) over the edge width _/\_ 
float ramptotri(float t, h){
    float a = 1-2*abs(0.5 - t);
    return a*h;
}

float ramptotri(float t){
    return 1-2*abs(0.5 - t);
}

// ==============================
// Useful geometry functions
// ==============================

// This is perhaps quite slow?
float curveuv(int ptnum, primnum){
    int v = pointvertex(geoself(), ptnum);
    int ind = vertexprimindex(geoself(), v);
    int npts = len(primpoints(0, primnum));
    return float(ind) / (npts-1);
}

int primpointsfrompt(int ptnum){
    int v = pointvertex(geoself(), ptnum);
    int ind = vertexprimindex(geoself(), v);
    int npts[] = primpoints(0, primnum);
}

// forward and reverse stereographic projection from 3D-4D
vector4 inverseStereo4(vector p; float mul) {
        float n = dot(p,p)+1;
        return set(p.x*(mul/n),p.y*(mul/n),p.z*(mul/n),(n-2)/n);
}

vector stereo4(vector4 p; float mul) {
        return set(p.x/(1-p.w),p.y/(1-p.w),p.z/(1-p.w));
        //return set(p.x/(1+p.w),p.y/(1+p.w),p.z/(1+p.w)); wrong but fun  
}

// Arrays

// shuffle array (Basic Fisher-Yates) NOT WORKING ###############################
void shuffle(int array[]){
    int n = len(array);
    if (n > 1) {
        for (int i = 0; i < (n - 1); i++) {
          int j = (i + n*int(rand(34334+i*123)))%n;
          int t = array[j];
          array[j] = array[i];
          array[i] = t;
        }
    }
}
